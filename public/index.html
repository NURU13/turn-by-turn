<!DOCTYPE html>
<html>
  <head>
    <style type="text/css">
      html { height: 100% }
      body { height: 100%; margin: 0 }
      #map { width: 100%; height: 100% }
    </style>
  </head>

  <body>
    <div id="map"></div>
    <div id="out"></div>

    <script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?sensor=false"></script>
    <script type="text/javascript">
      function interpolate(path, t) {
        var i, l

        t *= google.maps.geometry.spherical.computeLength(path)

        for(i = 1; i < path.length; i++) {
          l = google.maps.geometry.spherical.computeDistanceBetween(path[i - 1], path[i])

          if(t <= l)
            return google.maps.geometry.spherical.interpolate(path[i - 1], path[i], t / l)

          t -= l
        }

        return path[path.length - 1]
      }

      function extract(route, now, tripStep, maxTripLength) {
        var out = [],
            t = 0,
            elapsed = 0,
            i, leg, j, step, path

        out.push({
          position: route.legs[0].start_location,
          time: now + elapsed
        })

        legs: for(i = 0; i !== route.legs.length; i++) {
          leg = route.legs[i]

          for(j = 0; j !== leg.steps.length; j++) {
            step = leg.steps[j]
            t += step.duration.value

            if(t < tripStep)
              continue

            path = google.maps.geometry.encoding.decodePath(step.polyline.points)
            while(t >= tripStep) {
              elapsed += tripStep
              /* Early out if we've gone further than an hour. */
              if(elapsed >= maxTripLength) {
                t = 0
                break legs
              }

              t -= tripStep

              out.push({
                position: interpolate(path, 1 - t / step.duration.value),
                time: now + elapsed
              })
            }
          }
        }

        if(t > 0) {
          elapsed += t
          t = 0
          out.push({
            position: route.legs[route.legs.length - 1].end_location,
            time: now + elapsed
          })
        }

        return out
      }

      function json(url, callback) {
        var req = new XMLHttpRequest()
        req.open("GET", url, true)
        req.onreadystatechange = function() {
          if(req.readyState !== 4)
            return

          if(req.status !== 200)
            return callback(new Error("Received a non-200 response from the server (" + req.status + ")."))

          return callback(null, JSON.parse(req.responseText))
        }
        req.send(null)
      }

      function forecast(positions, callback) {
        var url = ["/darksky/"],
            i

        for(i = 0; i !== positions.length; i++)
          url.push(
            positions[i].position.lat().toFixed(6), ",",
            positions[i].position.lng().toFixed(6), ",",
            positions[i].time, ";"
          )

        url.pop()

        return json(url.join(""), function(err, res) {
          if(err)
            return callback(err)

          var i = res.precipitation.length

          while(i--) {
            positions[i].probability = res.precipitation[i].probability
            positions[i].intensity   = res.precipitation[i].intensity
            positions[i].error       = res.precipitation[i].error
            positions[i].type        = res.precipitation[i].type
          }

          return callback()
        })
      }

      function divide(positions) {
        var regions = [],
            region = null,
            i, w, j

        for(i = 0; i !== positions.length; i++) {
          w = positions[i].probability * positions[i].intensity

          if(w !== 0) {
            if(!region)
              region = {
                start:     false,
                end:       false,
                intensity: 0,
                data:      []
              }

            region.intensity = Math.max(region.intensity, w)
            region.data.push(positions[i])

            if(i === 0) region.start = true
            if(i === positions.length - 1) region.end = true
          }

          else if(region) {
            regions.push(region)
            region = null
          }
        }

        if(region) {
          regions.push(region)
          region = null
        }

        /* Strip out regions that are too short or small to matter
         * significantly. */
        i = regions.length
        while(i--)
          if(regions[i].length < 5 || regions[i].intensity < 2)
            regions.splice(i, 1)

        return regions
      }

      function polygon(map, region) {
        var m = 1 / 128,
            n = 1 / 8,
            projection = map.getProjection(),
            positions = region.data,
            points = [],
            i, w, a, b, c, dx, dy, k

        b   = projection.fromLatLngToPoint(positions[0].position)
        c   = projection.fromLatLngToPoint(positions[1].position)
        dx  = c.x - b.x
        dy  = c.y - b.y
        w   = m + positions[0].probability * positions[0].intensity * n / 75
        k   = w / Math.sqrt(dx * dx + dy * dy)
        dx *= k
        dy *= k
        points.push(
          projection.fromPointToLatLng(new google.maps.Point(b.x - dy, b.y + dx)),
          projection.fromPointToLatLng(new google.maps.Point(b.x + dy, b.y - dx))
        )

        if(region.start)
          new google.maps.Polyline({
            clickable: false,
            strokeColor: "red",
            strokeOpacity: 1,
            strokeWeight: 4,
            map: map,
            path: [
              projection.fromPointToLatLng(new google.maps.Point(b.x - dy, b.y + dx)),
              projection.fromPointToLatLng(new google.maps.Point(b.x + dy, b.y - dx))
            ]
          })

        for(i = 1; i !== positions.length - 1; i++) {
          a   = projection.fromLatLngToPoint(positions[i - 1].position)
          b   = projection.fromLatLngToPoint(positions[i    ].position)
          c   = projection.fromLatLngToPoint(positions[i + 1].position)
          dx  = c.x - a.x
          dy  = c.y - a.y
          w   = m + positions[i].probability * positions[i].intensity * n / 75
          k   = w / Math.sqrt(dx * dx + dy * dy)
          dx *= k
          dy *= k
          points.push(projection.fromPointToLatLng(new google.maps.Point(b.x + dy, b.y - dx)))
        }

        b   = projection.fromLatLngToPoint(positions[positions.length - 1].position)
        c   = projection.fromLatLngToPoint(positions[positions.length - 2].position)
        dx  = c.x - b.x
        dy  = c.y - b.y
        w   = m + positions[positions.length - 1].probability * positions[positions.length - 1].intensity * n / 75
        k   = w / Math.sqrt(dx * dx + dy * dy)
        dx *= k
        dy *= k
        points.push(
          projection.fromPointToLatLng(new google.maps.Point(b.x - dy, b.y + dx)),
          projection.fromPointToLatLng(new google.maps.Point(b.x + dy, b.y - dx))
        )

        if(region.end)
          new google.maps.Polyline({
            clickable: false,
            strokeColor: "red",
            strokeOpacity: 1,
            strokeWeight: 4,
            map: map,
            path: [
              projection.fromPointToLatLng(new google.maps.Point(b.x - dy, b.y + dx)),
              projection.fromPointToLatLng(new google.maps.Point(b.x + dy, b.y - dx))
            ]
          })

        for(i = positions.length - 2; i !== 0; i--) {
          a   = projection.fromLatLngToPoint(positions[i + 1].position)
          b   = projection.fromLatLngToPoint(positions[i    ].position)
          c   = projection.fromLatLngToPoint(positions[i - 1].position)
          dx  = c.x - a.x
          dy  = c.y - a.y
          w   = m + positions[i].probability * positions[i].intensity * n / 75
          k   = w / Math.sqrt(dx * dx + dy * dy)
          dx *= k
          dy *= k
          points.push(projection.fromPointToLatLng(new google.maps.Point(b.x + dy, b.y - dx)))
        }

        new google.maps.Polygon({
          clickable: false,
          fillColor: "orange",
          fillOpacity: 0.5,
          strokeWeight: 0,
          map: map,
          paths: points
        })
      }

      function draw(map, region) {
        var i = region.data.length,
            message = []

             if(region.intensity <  15) message.push("sporadic light")
        else if(region.intensity <  27) message.push("light")
        else if(region.intensity >= 45) message.push("heavy")

        message.push(region.data[0].type, "for", region.data.length, "minutes")
        message = message.join(" ")

        new google.maps.Marker({
          map: map,
          position: region.data[Math.floor(region.data.length * 0.5)].position,
          title: message
        })

        polygon(map, region)
      }

      var map = new google.maps.Map(document.getElementById("map"), {
            center: new google.maps.LatLng(42.7235, -73.6931),
            zoom: 12,
            mapTypeId: google.maps.MapTypeId.ROADMAP
          }),
          display = new google.maps.DirectionsRenderer(),
          service = new google.maps.DirectionsService()

      display.setMap(map)

      service.route({
        origin: "Yankton, SD",
        destination: "Sioux Falls, SD",
        travelMode: google.maps.TravelMode.DRIVING
      }, function(result, status) {
        if(status !== google.maps.DirectionsStatus.OK) {
          alert("Poop. Google error.")
          return
        }

        display.setDirections(result)

        var positions = extract(result.routes[0], Math.floor(Date.now() / 1000), 60, 3600)

        forecast(positions, function(err) {
          if(err) {
            alert("Sad panda, Dark Sky error: " + err.message)
            return
          }

          var regions = divide(positions),
              i = regions.length

          while(i--)
            draw(map, regions[i])
        })
      })
    </script>
  </body>
</html>
